#!/usr/bin/env python3
# %%

import json
import os
import sys
import time
from pathlib import Path
from shutil import copy, copytree, rmtree, ignore_patterns

import numpy as np
import pandas as pd

# os.chdir('../automator')
os.getcwd()


# %%
# =====================================
# LIBRARY-BASED COUPLING FUNCTIONS
# =====================================

def check_suews_library():
    """
    Check if SUEWS library and modules exist.
    Exit with clear error message if not found.
    """
    path_suews_lib = Path("../SUEWS/lib/libsuews.a")
    path_suews_include = Path("../SUEWS/include")

    print("=" * 60)
    print("CHECKING SUEWS LIBRARY")
    print("=" * 60)

    if not path_suews_lib.exists():
        print("\n❌ ERROR: SUEWS library not found!")
        print("=" * 60)
        print("\nYou must build the SUEWS library first:")
        print("  cd ../SUEWS/src/suews")
        print("  make -f Makefile.lib -j4")
        print("  make -f Makefile.lib install")
        print()
        sys.exit(1)

    if not path_suews_include.exists() or not list(path_suews_include.glob("*.mod")):
        print("\n❌ ERROR: SUEWS module files not found!")
        print("=" * 60)
        print("\nRun:")
        print("  cd ../SUEWS/src/suews")
        print("  make -f Makefile.lib install")
        print()
        sys.exit(1)

    # Get library size
    lib_size_mb = path_suews_lib.stat().st_size / (1024 * 1024)
    num_modules = len(list(path_suews_include.glob("*.mod")))

    print(f"\n✓ Found SUEWS library: {path_suews_lib}")
    print(f"  Size: {lib_size_mb:.1f} MB")
    print(f"  Modules: {num_modules} .mod files")
    print("=" * 60)
    print()


def inject_suews_link_flags(path_configure_wrf):
    """
    Automatically inject SUEWS library flags into configure.wrf.
    This function should be called AFTER WRF's ./configure runs.

    Modifies:
      - LIB: adds $(SUEWS_LDFLAGS)
      - INCLUDE_MODULES: adds $(SUEWS_CPPFLAGS)

    And includes wrf_suews.mk at the top of the file.
    """
    if not path_configure_wrf.exists():
        print(f"\n⚠️  WARNING: {path_configure_wrf} not found")
        print("Run ./configure in the compilation directory first.")
        return

    print("=" * 60)
    print("PATCHING configure.wrf FOR SUEWS LINKING")
    print("=" * 60)

    with open(path_configure_wrf, 'r') as f:
        lines = f.readlines()

    # Check if already patched
    include_line = 'include $(WRF_SRC_ROOT_DIR)/../SUEWS/lib/wrf_suews.mk\n'
    if include_line in lines:
        print("✓ configure.wrf already patched for SUEWS")
        return

    # Insert include at line 2 (after the first comment line)
    lines.insert(1, '\n')
    lines.insert(2, '# SUEWS library configuration (auto-generated by coupling-automator)\n')
    lines.insert(3, include_line)
    lines.insert(4, '\n')

    # Modify LIB and INCLUDE_MODULES lines
    for i, line in enumerate(lines):
        if line.startswith('LIB ') and '$(SUEWS_LDFLAGS)' not in line:
            lines[i] = line.rstrip() + ' $(SUEWS_LDFLAGS)\n'
        elif line.startswith('INCLUDE_MODULES ') and '$(SUEWS_CPPFLAGS)' not in line:
            lines[i] = line.rstrip() + ' $(SUEWS_CPPFLAGS)\n'

    # Write back
    with open(path_configure_wrf, 'w') as f:
        f.writelines(lines)

    print("✓ configure.wrf patched successfully")
    print("  - Added include for wrf_suews.mk")
    print("  - Added SUEWS_LDFLAGS to LIB")
    print("  - Added SUEWS_CPPFLAGS to INCLUDE_MODULES")
    print("=" * 60)
    print()


# %%


def find_add(path_file, in_file, query, to_add):

    print("Reading file:" + in_file)
    with open(path_file / in_file, "r") as ifile:  # Reading the file
        buf = ifile.readlines()

    out_file = in_file

    print("Writing file:" + out_file)
    with open(path_file / out_file, "w") as ofile:
        for line in buf:
            if query in line:
                # do this later on `to_add` as a list to store multiline strings
                line = line + "\n".join(to_add) + "\n"
                # line = line+to_add+'\n'
            ofile.write(line)

    print(f"Modifying {in_file} is finished\n")


# %%
# =====================================
# DIRECTORY VALIDATION
# =====================================

def validate_working_directory():
    """
    Validate that script is running from correct directory.
    Exit with clear error if not in coupling-automator/.
    """
    script_dir = Path(__file__).parent.resolve()
    expected_dir_name = "coupling-automator"

    if script_dir.name != expected_dir_name:
        print("\n❌ ERROR: Script not running from correct directory!")
        print("=" * 60)
        print(f"\nCurrent directory: {script_dir}")
        print(f"Expected: .../{expected_dir_name}/")
        print("\nPlease run from coupling-automator directory:")
        print("  cd coupling-automator")
        print("  python3 automate_main.py")
        print("  # OR")
        print("  make")
        print()
        sys.exit(1)

    return script_dir


def validate_paths(script_dir):
    """
    Validate that required directories exist relative to script location.
    """
    # Establish absolute base paths
    base_dir = script_dir.parent
    path_src_WRF = base_dir / "WRF"
    path_src_SUEWS = base_dir / "SUEWS" / "src" / "suews"

    print("=" * 60)
    print("VALIDATING DIRECTORY STRUCTURE")
    print("=" * 60)

    # Check WRF submodule
    if not path_src_WRF.exists():
        print(f"\n❌ ERROR: WRF submodule not found!")
        print(f"  Expected: {path_src_WRF}")
        print("\nInitialise submodules:")
        print("  git submodule init")
        print("  git submodule update")
        print()
        sys.exit(1)

    # Check SUEWS submodule
    if not path_src_SUEWS.exists():
        print(f"\n❌ ERROR: SUEWS source directory not found!")
        print(f"  Expected: {path_src_SUEWS}")
        print("\nInitialise submodules:")
        print("  git submodule init")
        print("  git submodule update")
        print()
        sys.exit(1)

    # Check changes_list.json
    changes_file = script_dir / "changes_list.json"
    if not changes_file.exists():
        print(f"\n❌ ERROR: changes_list.json not found!")
        print(f"  Expected: {changes_file}")
        print()
        sys.exit(1)

    print(f"\n✓ WRF source: {path_src_WRF}")
    print(f"✓ SUEWS source: {path_src_SUEWS}")
    print(f"✓ Configuration: {changes_file}")
    print("=" * 60)
    print()

    return path_src_WRF, path_src_SUEWS


# %%
# =====================================
# MAIN COUPLING WORKFLOW
# =====================================

print("\n")
print("=" * 70)
print(" WRF-SUEWS COUPLING AUTOMATION (Library-Based)")
print("=" * 70)
print()

# Validate working directory and paths
script_dir = validate_working_directory()
path_src_WRF, path_src_SUEWS = validate_paths(script_dir)

# Check SUEWS library exists before starting
check_suews_library()

with open("changes_list.json") as fn_json:
    change_list = json.load(fn_json)

# %%
# working directory for WRF-SUEWS coupling
# to hold all the coupling modifications

today = time.strftime("%Y%m%d")
path_working = Path(f"../compilation-{today}")

# create new folder if not existing:
if not path_working.exists():
    path_working.mkdir(parents=True)


# %%
# suggested workflow:
# 1. make $dir_WRF_SUEWS if not existing
if path_working.exists():
    print(str(path_working), " already exists. Removing ", str(path_working))
    rmtree(path_working)


# %%
# 2. copy all files/dirs from `path_src_WRF` to `path_working`
print("copying from " + str(path_src_WRF) + " to " + str(path_working))
try:
    copytree(
        path_src_WRF,
        path_working,
        ignore_dangling_symlinks=True,
        ignore=ignore_patterns(".git*"),
    )
except:
    print("some of the files are not copied. Check Symlinks files")
    pass


# %%
# 3 run script to modify the files
for in_file in change_list.keys():
    path_file = path_working / change_list[in_file]["filePath"]
    # path_file = path_file.resolve()
    path_file_WRF = path_src_WRF / change_list[in_file]["filePath"]
    print(path_file, "existing?", path_file.exists())

    query = change_list[in_file]["query"]
    for qkey, qval in query.items():
        find_add(path_file, in_file, qkey, qval)


# %%
# 4. Copy SUEWS wrapper and registry files to WRF directory
# NOTE: We NO LONGER generate module_sf_suewsdrv.F (monolithic merge)
# Instead, we link against the pre-built libsuews.a library
print("\n")
print("=" * 60)
print("COPYING SUEWS COUPLING FILES")
print("=" * 60)
list_file_to_copy = [
    # (file to copy, destination in working folder)
    ("module_sf_suews.F", "phys"),
    ("registry.suews", "Registry"),
    ("namelist.suews", "test/em_real"),
]
for file, dst in list_file_to_copy:
    print(f"Copying {file} → {dst}")
    copy(file, path_working / dst)
    file_copied = path_working / dst / file
    print(f"  ✓ {file_copied}")

print("=" * 60)
print()

# %%
# 5. Print next steps
print("\n")
print("=" * 70)
print(" WRF-SUEWS COUPLING SETUP COMPLETE")
print("=" * 70)
print()
print("Next steps:")
print()
print("  1. Configure WRF:")
print(f"     cd {path_working}")
print("     ./configure")
print()
print("  2. Patch configure.wrf for SUEWS (optional - can be done manually):")
print("     cd ../coupling-automator")
print("     python patch_configure.py")
print()
print("  3. Compile WRF-SUEWS:")
print(f"     cd {path_working}")
print("     ./compile em_real >& log.compile")
print()
print("=" * 70)
print()

# Create a simple helper script to patch configure.wrf
patch_script_path = Path("patch_configure.py")
with open(patch_script_path, "w") as f:
    f.write("""#!/usr/bin/env python3
\"\"\"
Helper script to patch configure.wrf with SUEWS library flags.
Run this AFTER running ./configure in the compilation directory.
\"\"\"
import sys
from pathlib import Path

# Import the injection function
sys.path.insert(0, str(Path(__file__).parent))
from automate_main import inject_suews_link_flags
import time

today = time.strftime("%Y%m%d")
path_working = Path(f"../compilation-{today}")
path_configure_wrf = path_working / "configure.wrf"

if __name__ == "__main__":
    inject_suews_link_flags(path_configure_wrf)
""")
